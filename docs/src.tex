\documentclass[a4paper, 14pt]{extarticle}
\usepackage{graphicx}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{setspace,amsmath}
\usepackage[left=20mm, top=15mm, right=15mm, bottom=15mm, nohead, footskip=10mm]{geometry} % Настройки полей документа

\graphicspath{ {./images/} }

\makeatletter
\def\@seccntformat#1{%
  \expandafter\ifx\csname c@#1\endcsname\c@section\else
  \csname the#1\endcsname\quad
  \fi}
\makeatother

\begin{document} % Начало документа

% Начало титульного листа
\begin{center}
    \normalsize{\textbf{МИНИСТЕРСТВО ОБРАЗОВАНИЯ РЕСПУБЛИКИ БЕЛАРУСЬ}}\\
    \hfill \break
    \normalsize{\textbf{БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ}}\\
    \hfill \break
    \small{\textbf{ФАКУЛЬТЕТ ПРИКЛАДНОЙ МАТЕМАТИКИ И ИНФОРМАТИКИ}}\\
    \hfill \break
    \large{Кафедра математического моделирования и анализа данных}\\
    \vspace{40mm}
    \normalsize{Отчёт}\\
    \hfill \break
    \normalsize{О прохождении преддипломной практики}\\
    \hfill \break
    \normalsize{Криптография на основе функций хэширования:\\ подписи без состояния}\\
    \hfill \break
\end{center}

\begin{flushright}
    \vspace{20mm}
    Болтач Антон Юрьевич\\
    Студент 4 курса 9 группы\\
    Научный руководитель\\
    С. В. Агиевич\\
\end{flushright}

\vfill
\begin{center}
    Минск, 2020 г.
\end{center}
\thispagestyle{empty} % Выключаем отображение номера для этой страницы
    
% Конец титульного листа

\newpage

% Содержание
\tableofcontents
\newpage

% Введение
% Концепции Hash-based crypto
\section{Введение}
Цифровые подписи широко используются в Интернете, в частности, для аутентификации, проверки целостности и отказа от авторства. Алгоритмы цифровой подписи, наиболее часто используемые на практике - RSA, DSA и ECDSA, - основаны на допущениях твердости о задачах теории чисел, а именно факторизации составного целого числа и вычислении дискретных логарифмов. В 1994 году Питер Шор показал, что эти теоретические проблемы с числами могут стать решаемыми при наличии квантовых вычислений. Квантовые компьютеры могут решить их за полиномиальное время, ставя под угрозу безопасность схем цифровой подписи, используемых сегодня. Хотя квантовые компьютеры еще не доступны, их развитие происходит быстрыми темпами и поэтому представляет собой реальную угрозу в течение следующих десятилетий. К счастью, постквантовая криптография предоставляет множество квантовостойких альтернатив классическим схемам цифровой подписи. Подписи на основе хэша или подписи Меркля, как они также известны, являются одной из наиболее многообещающих из этих альтернатив.
\subsection{Почему Hash-Based Signatures?}
Есть много причин использовать схемы подписи на основе хэша и предпочитать их другим альтернативам. Хотя в самой ранней схеме подписи отсутствуют практические требования к производительности и пространству, современные схемы на основе хэшей, такие как XMSS, достаточно быстры, при небольшом размере. Также требования безопасности являются убедительными. Использование такой схемы подписи всегда требует хэш-функции. В то время как другие схемы подписи полагаются на дополнительные предположения о неразрешимости для генерации подписи, для решения на основе хэша требуется только безопасная хэш-функция. Некоторые схемы, основанные на хэше, даже уменьшают потребность в хэш-функции, устойчивой к столкновениям, до той, которая должна выдерживать атаки только на второе изображение. В качестве примера известны практические атаки средствами защиты от столкновений функции MD5, но мы до сих пор не знаем о виртуальных атаках на второе изображение.
\newpage

% Одноразовые подписи
\section{Одноразовые подписи(OTS)}
Одноразовые подписи (OTS) называются одноразовыми, поскольку сопутствующие сокращения безопасности гарантируют безопасность только при атаках с одним сообщением. Однако это не означает, что эффективные атаки возможны при атаках с двумя сообщениями. Особенно в контексте основанных на хэшировании OTS (которые являются основными строительными блоками последних предложений по стандартизации) это приводит к вопросу о том, приводит ли случайное повторное использование одноразовой пары ключей к немедленной потере безопасности. Проанализируем безопасность наиболее известных хэш-основанных OTS: $WOTS$, $WOTS^{+}$ при различных видах атак с двумя сообщениями. Интересно, что оказывается, что схемы все еще безопасны при двух атаках сообщений, асимптотически.
\subsection{Одноразовая подпись Винтерница($WOTS$)}
WOTS использует функцию сохранения длины (криптографический хэш) $F : \{0, 1\}^{n} \rightarrow \{0, 1\}^{n}$. Она параметризуется длиной сообщения $m$ и параметром $Winternitz$, $w \in N$, $w > 1$, который определяет компромисс между временем и памятью. Эти два параметра используются для вычисления
\[ l_{1} = \Bigg \lceil \frac{m}{log(w)} \Bigg \rceil, l_{2} = \Bigg \lfloor \frac{log(l_{1}(w - 1))}{log(w)} \Bigg \rfloor + 1, l = l_{1} + l_{2}. \]
Схема использует $w - 1$ итерации $F$ на случайном входе. Мы определяем их как
\[ F^{a}(x) = F(F^{a - 1}(x)) \]
и $F^{0}(x) = x$.

Теперь опишем три алгоритма схемы:

Алгоритм генерации ключей $(kg(1^{n}))$: На входе параметр безопасности $1^{n}$ алгоритм генерации ключей выбирает $l$ $n$-битовых блоков строки равномерно, случайным образом. Личный ключ $sk = (sk_{1}, ..., sk_{l})$ состоит из этих $l$ блоков случайных битовых строк. Открытый ключ проверки $pk$ вычисляется как
\[ pk = (pk_{1}, ..., pk_{l}) = (F^{w - 1}(sk_{1}), ..., F^{w - 1}(sk_{l})) \]

Алгоритм подписи$(sign(1^{n}, M^{*}, sk))$: На входе параметр безопасности $1^{n}$, сообщение $M^{*}$ длины $m$ и личного ключа подписи $sk$, алгоритм подписи сначала вычисляет базовое $w$ представление $M^{*}: M^{*} = (M^{*}_{1}, ..., M^{*}_{l_{1}}), M^{*}_{i} \in \{0, ..., w - 1\}$. Далее он вычисляет контрольную сумму
\[ C = \sum^{l_{1}}_{i = 1}(w - 1 - M^{*}_{i}) \]

и вычисляет его базовое $w$ представление $C = (C_{1}, ..., C_{l_2})$. Длина базового $w$ представления $C$ не более $l_{2}$, так как $C \leq l_{1}(w - 1)$. Мы задаем $B = (B_{1}, ..., B_{l}) = M^{*} || C$. Подпись вычисляется как
\[ \sigma = (\sigma_{1}, ..., \sigma_{l}) = (F^{B_1}(sk_{1}), ..., F^{B_l}(sk_{l})) \].

Алгоритм проверки $(vf(1^{n}, M^{*}, \sigma, pk))$: На входе параметр безопасности $1^{n}$, сообщение $M^{*}$ длины $m$, подпись $\sigma$ и открытый ключ проверки $pk$, алгоритм проверки сначала вычисляет $B_{i}$, $ 1 \leq i \leq l$, как описано выше. Затем он выполняет следующее сравнение:
\[ pk = (pk_{1}, ..., pk_{l}) \stackrel{?}= (F^{w - 1 - B_{1}}(\sigma_{1}), ..., (F^{w - 1 - B_{l}}(\sigma_{l})) \]

Если сравнение выполняется, оно возвращает true и false в противном случае.
\subsection{Дополненная подпись Винтерница($WOTS^{+}$)}
Теперь опишем $WOTS^{+}$. Как и все варианты $W-OTS$, $W-OTS^{+}$ параметризуется параметром безопасности $n \in N$, длиной сообщения $m$ и параметром $w \in N$, $w > 1$, который определяет компромисс между временем и памятью. Последние два параметра используются для вычисления
\[ l_{1} = \Bigg \lceil \frac{m}{log(w)} \Bigg \rceil, l_{2} = \Bigg \lfloor \frac{log(l_{1}(w - 1))}{log(w)} \Bigg \rfloor + 1, l = l_{1} + l_{2}. \]

Кроме того, $W-OTS^{+}$ использует семейство функций $F_{n} : \{f_{k} : \{0, 1\}^{n} \rightarrow \{0, 1\}^{n}|k \in K_{n}\}$ с ключевым пространством $K_{n}$. Можно предположить как о криптографическом семействе хэш-функций, которое не сжимается. Используя $F_{n}$, мы определяем следующую цепную функцию.

$c^{i}_{k}(x, r):$ На входе значения $x \in \{0, 1\}^{n}$, счетчика итераций $i \in N$, ключа $k \in K$ и элементы рандомизации $r = (r_{1}, ..., r_{j}) \in \{0, 1\}^{n \times j}$ при $j \geq i$, цепная функция работает следующим образом. В случае $i = 0$, $c$ возвращает $x(c^{0}_{k}(x, r) = x)$. Для $i > 0$ мы определяем $c$ рекурсивно как
\[ c^{i}_{k}(x, r) = f_{k}(c^{i - 1}_{k}(x, r) \oplus r_{i}) ,\]

То есть в каждом раунде функция сначала принимает побитовый $xor$ промежуточного значения и битовую маску $r$, затем оценивает $f_{k}$ на результат. Мы пишем $r_{a,b}$ для подмножества $r_{a}, ..., r_{b}$ как $r$. В случае $b < a$ мы определяем $r_{a,b}$ как пустую строку. Будем считать, что параметры $m$, $w$ и семейство функций $F_{n}$ общеизвестны. Теперь мы опишем три алгоритма $W-OTS^{+}$:

Алгоритм генерации ключа $(Kg(1^n))$: При вводе параметра безопасности $n$ унарно, алгоритм генерации ключа выбирает $l + w - 1$ $n$-бит строки равномерно случайным образом. Личный ключ $sk = (sk_{1}, ..., sk_{l})$ состоит из первых $l$ случайных битовых строк. Оставшиеся $w - 1$ бит строки используются в качестве элементов рандомизации $r = (r_{1}, ..., r_{w - 1})$ для $c$. Далее, $Kg$ выбирает функцию ключа $k \stackrel{\$}\leftarrow K$ равномерно случайным образом. Открытый ключ проверки $pk$ вычисляется как
\[ pk = (pk_{0}, pk_{1}, ..., pk_{l}) = ((r, k),c^{w - 1}_{k}(sk_{1},r), ..., c^{w - 1}_{k}(sk_{l}, r)). \]

Алгоритм подписи $(Sign(M, sk, r))$: На входе $m$ битного сообщения $M$, личного ключа подписи $sk$ и элементов рандомизации $r$, алгоритм подписи сначала вычисляет базовое $w$ представление $M: M = (M_{1} . . . M_{l_{1}} )$, $M_{i} \in \{0, ..., w - 1\}$. Поэтому $M$ рассматривается как двоичное представление натурального числа $x$, а затем вычисляется $w$ бинарное представление $x$. Далее вычисляем контрольную сумму
\[ C = \sum^{l_{1}}_{i = 1}(w - 1 - M_{i}) \]

и его базовое $w$ представление $C = (C_{1}, ..., C_{l_{2}})$. Длина базового $w$ представления $C$ не более $l_{2}$, так как $C \leq l_{1}(w - 1)$. Мы задаем $B = (b_{1}, ..., b_{l}) = M || C$, конкатенация базовых $w$ представлений $M$ и $C$. Подпись вычисляется как
\[ \sigma = (\sigma_{1}, ..., \sigma_{l}) = (c^{b_{1}}_{k}(sk_{1},r), ..., c^{b_{l}}_{k}(sk_{l},r)). \]

Обратите внимание, что контрольная сумма гарантирует, что с учетом \newline
$b_{i}, 0 < i \leq l$, соответствующего одному сообщению, $b^{*}_{i}$ соответствующий любому другому сообщению включает по крайней мере один $b^{*}_{i} < b_{i}$.

Алгоритм проверки $(Vf(1^n, M, \sigma, pk))$: На входе сообщение $M$ двоичной длины $m$, подпись $\sigma$ и открытый ключ $pk$. Алгоритм проверки сначала вычисляет $b_{i}, 1 \leq i \leq l$, как описано выше. Затем он выполняет следующее сравнение:
\[ pk = (pk_{0}, pk_{1}, ..., pk_{l}) \stackrel{?}{=} ((r,k),c^{w - 1 - b_{1}}_{k}(\sigma_{1}, r_{b_{1} + 1, w - 1}, ..., c^{w - 1 - b_{l}}_{k}(\sigma_{l}, r_{b_{l} + 1, w - 1})) \]

Если сравнение выполняется, оно возвращает true и false в противном случае.

Время выполнения всех трех алгоритмов ограничено $lw$ оценками $f_{k}$. Размер подписи и личного ключа составляет $|\sigma| = |sk| = ln$ бит. Размер открытого ключа равен $(l + w - 1)n + |k|$ бит, где $|k|$ обозначает количество бит, необходимых для представления любого элемента $K$.
\subsubsection{Обоснование стойкости($WOTS^{+}$)}
В этом разделе мы анализируем безопасность $WOTS^{+}$.

Определение($\epsilon$-доступность обнаружения подделки). $\epsilon$-доступность обнаружения подделки($\epsilon$-FDA) для одноразового $WOTS^{+}$ S определяется следующим экспериментом.
\newpage
Эксперимент $Exp^{F D A}_{S,n}(A)$

\hspace{10mm} $(sk, pk) \leftarrow S.Kg(1^n)$

\hspace{10mm} $(M^{*}, \sigma^{*}) \leftarrow A^{Sign(sk,\cdot)}$

Пусть $(M, \sigma)$ будьте парой запрос-ответ $Sign(sk,\cdot)$.

Вернём 1, если $S.Sign(sk, M^{*}) \rightarrow \sigma^{*}, S.Vf(pk, \sigma^{*}, M^{*}) \rightarrow 1, M^{*} \neq M$.

Тогда схема $WOTS^{*}$ $S$ имеет $\epsilon-FDA$, если нет противника $A$, который преуспевает с вероятностью $\geq \epsilon$.

Построим схему $(n, \delta, L, \nu)-W-OTS^{+}$ следующим образом.

Введем параметр $\nu \in \{1, 2, ...\}$ определение длины блоков, в которых сообщение разбивается во время алгоритма подписи, где мы предполагаем, что $L$ кратно $\nu$. Введем следующие вспомогательные значения:
\[w := 2^{\nu}, l_{1} := \lceil L/\nu \rceil, l_{2} := \lfloor log_{2}(l_{1}(w - 1))/\nu \rfloor + 1, l := l_{1} + l_{2}\].

Затем рассмотрим семейство односторонних функций:
\[ f^{(i)}_{r} : \{0,1\}^{n+\delta(w - i)} \rightarrow \{0,1\}^{n+\delta(w - i - 1)} \],

где $i \in {1, ..., w - 1}$ и параметр $r$ принадлежит некоторой области $D$. Мы предполагаем, что $f^{(i)}_{r}$ удовлетворяет случайному предположению оракула для равномерно случайно выбранного $r$ из $D$. Использование этого параметра может соответствовать $XOR$ некоторого семейства хэш-функций со случайной битовой маской.

Затем мы вводим цепную функцию $F^{(i)}_{r}$, которую мы определяем рекурсивно следующим образом:
\[F^{(0)}_{r}(x) = x, F^{(i)}_{r}(x) = f^{(i)}_{r}(F^{(i - 1)}_{r}(x)), i \in \{1, ..., w - 1\}.\]

Алгоритмы схемы $(n, \delta, L, \nu)-W-OTS^{+}$ следующие:

Алгоритм генерации пары ключей $((sk, pk) \leftarrow (n, \delta, L, \nu)-WOTS^{+}.Kg)$. Сначала алгоритм генерирует личный ключ в следующем виде:
\[sk := (r, sk_{1}, sk_{2}, ..., sk_{l}), sk_{i} \stackrel{\$}{\leftarrow} \{0, 1\}^{n+\delta(w - 1)}, r \stackrel{\$}{\leftarrow} D\]
(Смотрите Рис. \ref{fig:wots1}). Затем открытый ключ, состоящий из рандомизирующего параметра $r$ и результаты цепной функции, используемой для $sk_{i}$ следующим образом:
\[ pk := (r, pk_{1}, pk_{2}, ..., pk_{l}), pk_{i} := F^{w - 1}_{r}(sk_{i})\]
Алгоритм подписи $(\sigma \leftarrow (n, \delta, L, \nu)-WOTS^{+}.Sign(sk, M))$. Сначала алгоритм вычисляет базовое $w$ представление $M$, разбивая его на $\nu$-битные блоки $(M = (m_{1}, ..., m_{l_{1}})$, где $m_{i} \in \{0, ..., w - 1\})$. Мы называем это частью сообщения. Затем алгоритм вычисляет контрольную сумму
\[ C := \sum^{l_{1}}_{i = 1}(w - 1 - m_{i}) \]
и его базовое $w$ представление $C = (c_{1}, ..., c_{l_{2}})$. Мы называем это контрольной суммой. Определим расширенную строку $B = (b_{1}, ..., b_{l}) := M||C$ как конкатенация частей сообщения и контрольной суммы. Наконец, подпись генерируется следующим образом:
\[ \sigma = (\sigma_{1}, ..., \sigma_{l}), \sigma_{i} := F^{(b_{i})}_{r}(sk_{i}). \]
Алгоритм проверки $(\nu \leftarrow (n, \delta, L, \nu)-WOTS^{+}.Vf(pk, \sigma, M))$. Идея алгоритма состоит в том, чтобы восстановить открытый ключ из заданной подписи $\sigma$ и затем проверить, совпадает ли он с исходным открытым ключом $pk$. Во-первых, алгоритм вычисляет базовую $w$ строку $B = (B_{1}, ..., B_{l})$ таким же образом, как и в алгоритме подписи (см. выше). Затем для каждой части подписи $\sigma_{i}$ алгоритм вычисляет оставшуюся часть цепочки следующим образом:
\[pk^{check}_{i} := f^{(w - 1)}_{r} \circ ... \circ f^{(b_{i}+1)}_{r}(\sigma_{i}),\]
где $\circ$ композиция функций. Если $pk^{check}_{i} = pk_{i}$ для всех $i \in \{1, ..., l\}$, затем алгоритм выводит $\nu := 1$, иначе $\nu := 0$.
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.7]{WOTS+_1.png}
    \caption{Основной принцип построения открытого ключа в схеме $(n, \delta, L, \nu)-WOTS^{+}$ }
    \label{fig:wots1}
\end{figure}

Основной результат по свойству FDA схемы $(n, \delta, L, \nu)-W-OTS^{+}$ можно сформулировать следующим образом:

Теорема $(n, \delta, L, \nu)-W-OTS^{+}$ схема имеет свойство $\epsilon-FDA$ с $\epsilon < 5.22 \times 2^{-\delta}$.

Доказательство. Рассмотрим сценарий успешного CMA на схеме $(n, \delta, L, \nu)-W-OTS^{+}$, в которой противник сначала заставляет законного пользователя с открытым ключом $pk = (r, pk_{1}, ..., pk_{l})$, чтобы предоставить ему подпись $\sigma = (\sigma_{1}, ..., \sigma_{l})$ для некоторого сообщения $M$, а затем генерировать действительную подпись $\sigma^{*} = (\sigma^{*}_{1}, ..., \sigma^{*}_{l})$ для какого-то сообщения $M^{*} \neq M$. Пусть $(m_{1}, ..., m_{l})$ и $(m^{*}_{1}, ..., m^{*}_{l})$ будет $w$-образных представлений $M$ и $M^{*}$ соответственно. Рассмотрим расширенные $w$-базовые строки $B = (b^{0}_{1}, ..., b^{0}_{l})$ и $B^{*} = (b^{*}_{1}, ..., b^{*}_{l})$ генерируется путем добавления частей контрольной суммы. Легко видеть, что для любого отличного $M$ и $M^{*}$ существует по крайней мере одна позиция $j \in \{1, ..., l\}$ такой, что $b^{*}_{j} < b_{j}$. Действительно, даже если для всех позиций $i \in \{1, ..., l_{1}\}$ случилось, что $m^{*}_{i} > m_{i}$, из определения контрольной суммы следует, что существует позиция $j \in \{l_{1} + 1, ..., l_{2}\}$ в части суммы такие, что $b^{*}_{j} < b_{j}$.

Поскольку $\sigma^{*}$ допустима ли подпись для $M^{*}$ мы имеем:
\[f^{(w - 1)}_{r} \circ ... \circ f^{(b^{*}_{j} + 1)}_{r}(\sigma^{*}_{j}) = pk_{j}.\]
Можно видеть, что событие подделки будет обнаружено, если $j^{th}$ часть подписи законного пользователя $M^{*}$ отличается от фальшивого (см. также Рис. \ref{fig:wots2}), так что:
\[\stackrel{\sim}{\sigma^{*}_{j}} := F^{(b^{*}_{j})}_{r}(sk_{j}) \neq \sigma^{*}_{j}.\]
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.7]{WOTS+_2.png}
    \caption{Иллюстрация принципа построения доказательство подделки типа 2 для схемы $(n, \delta, L, \nu)-WOTS^{+}$. }
    \label{fig:wots2}
\end{figure}
Рассмотрим два возможных случая. Во-первых, условие из теоремы выполняется, но справедливо следующее соотношение:
\[f^{(b_{j})}_{r} \circ ... \circ f^{(b^{*}_{j}+1)}_{r}(\sigma^{*}_{j}) \neq \sigma_{j}.\]
В этом случае мы получаем $\stackrel{\sim}{\sigma^{*}_{j}} \neq \sigma^{*}_{j}$ с единичной вероятностью так как
\[\sigma_{j} = f^{(b_{j})}_{r} \circ ... \circ f^{(b^{*}_{j}+1)}_{r}(\stackrel{\sim}{\sigma^{*}_{j}}) \neq f^{(b_{j})}_{r} \circ ... \circ f^{(b^{*}_{j}+1)}_{r}(\sigma^{*}_{j}).\]
Во втором случае мы имеем следующее тождество:
\[f^{(b_{j})}_{r} \circ ... \circ f^{(b^{*}_{j}+1)}_{r}(\sigma^{*}_{j}) = \sigma_{j},\]
что автоматически подразумевает выполнение условия теоремы. Рассмотрим функцию
\[F := f^{(b_{j})}_{r} \circ ... \circ f^{(b^{*}_{j}+1)}_{r} : \{0, 1\}^{n^{*} + \delta \Delta} \rightarrow \{0,1\}^{n^{*}},\]
где $\Delta := b^{0}_{j} - b^{*}_{j} \geq 1$ и $n^{*} := n + \delta(w - b^{*}_{j} - 1)$. Эта функция удовлетворяет случайным предположениям оракула, так как каждый из $\{f^{(k)}_{r}\}^{b_{j}}_{k=b^{*}_{j}}$. Следовательно мы имеем вероятность того, что противник получит $\sigma^{*}_{j} = \stackrel{\sim}{\sigma^{*}_{j}}$ с ограничением $\epsilon < 5.22 \times 2^{-\delta \Delta} \leq 5.22 \times 2^{-\delta}$. Что и требовалось доказать.
\newpage

% Деревья Меркля
\section{Деревья Меркля(MSS)}
Первый способ создать схему многократной подписи из схемы одноразовой подписи - использовать конструкцию, предложенную Мерклом в 1989 году. Учитывая целые числа $n$, $h$ и хэш-функцию $H$ : $\{0, 1\}^{2n} \rightarrow \{0, 1\}^{n}$, так называемое Дерево Меркля представляет собой двоичное дерево высоты $h$, узлы которого помечены значением $x \in \{0, 1\}^{n}$, таким образом, что значение каждого внутреннего узла вычисляется как $x = H(y||z)$, где $y$ и $z$ - значения левых и правых дочерних элементов.

Корневое значение $r$ может быть сначала отправлено для последующей аутентификации любого из $2^{h}$ листового значения $v_{1}, ..., v_{2^h}$. Действительно, чтобы проверить, что значение $v$ находится в листовом индексе $i$, нужно просто $v$, $i$ и путь аутентификации $i$. Этот путь аутентификации содержит братьев и сестер всех узлов на пути между листом $i$ и корнем (значения $h$). Это позволяет рекурсивно вычислять значения внутренних узлов вплоть до корня и сравнивать результат с $r$.

Эта конструкция позволяет превратить схему одноразовой подписи в схему многократной подписи следующим образом. Учитывая $2^h$ экземпляров OTS, подписывающий создает дерево Меркля, каждое листовое значение которого являются открытым ключом экземпляра OTS. Общий открытый ключ - это корневое значение. $i$-я подпись содержит подпись, сгенерированную $i$-м экземпляром OTS, а также путь аутентификации $i$.

Следовательно, открытый ключ содержит только $n$ битов, по сравнению с подходом $2^h$ OTS открытых ключей. Однако время генерации ключа экспоненциально в $h$, потому что на этом этапе необходимо вычислить полное дерево Меркля. Например, $h$ = 20 возможно, но может быть недостаточно для всех подписывающих. Кроме того, подписывающий должен отслеживать индексы $i$, которые уже были использованы, поэтому схема является $stateful$.
\newpage

% Многоразовые подписи
\section{Многоразовые подписи(MTS)}
В то время как одноразовые подписи обеспечивают удовлетворительную криптографическую безопасность для подписания и проверки транзакций, для них характерен существенный недостаток - их можно использовать безопасно только один раз. Поэтому существуют схемы подписи для включения более чем одной действительной одноразовой подписи, что позволяет сформировать предварительно столько подписей, сколько будет пар ключей одноразовых подписей. Логичным путем достижения этого является построение двоичного хэш-дерева, известного как дерево Меркля.
\subsection{HORS}
HORS - это несколькоразовая схема подписи. Пусть $f$ - односторонняя функция, а $H$ - хэш-функция, которая выводит случайный размер подмножества $\{1,2,...,t\}$, где $k$ и $t$ - параметры, влияющие на безопасность с помощью $k < t$. Ключ подписи - это случайный кортеж $(s_1,...,s_t)$, а открытым ключом является $(f(s_{1}),..., f(s_{t}))$. 
Теперь, чтобы подписать $m$ сообщение, вычислить набор $S = H(m)$ и выходной $\{s_{i} : i \in S\}$. Чтобы проверить, примените $f$ к каждому элементу подписи и проверьте, соответствует ли он открытому ключу. Каждая подпись раскрывает $k$ элементы личного ключа, поэтому в зависимости от выбора $k$ и $t$ несколько сообщений могут быть подписаны до того, как безопасность будет нарушена. Это было использовано в качестве строительного блока в SPHINCS, который представляет собой схему подписи на основе хэша без состояния, которая позволяет подписывать неограниченные сообщения.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.66]{HORS.png}
    \caption{Схема подписи HORS}
    \label{fig:hors}
\end{figure}
\subsection{PORS}
Начнём с того, что PORS, более безопасный вариант HORS. Как мы видели, современные схемы с несколькими временными подписями основаны на хэше для получения случайного подмножества (HORS). Тем не менее, HORS была изучена лишь частично, так как Рейзин и Рейзин(отец и сын) рассматривали только неадаптивные атаки. В частности, HORS подвержен адаптивным атакам, которые усугубляются простотой HORS: возьмите выход хэш-функции и разделите его на блоки, чтобы получить набор индексов. Действительно, ничто не мешает некоторым из этих индексов сталкиваться, уменьшая размер полученного подмножества и уменьшая безопасность. Несмотря на то, что HORS блестит своей простотой и скоростью по сравнению с более сложными методами получения случайных подмножеств гарантированного размера, его скорость не критична в сложных схемах, таких как SPHINCS, для которых голоса и деревья Меркля доминируют в вычислительных затратах. Поэтому рассмотрим новую конструкцию, использующую PRNG для получения случайного подмножества, которое мы называем PORS. Вместо того, чтобы использовать хэш-функцию, мы разделяем PRNG из сообщения и выполняем запрос к ней, пока мы не получим подмножество различных индексов к Рис. \ref{fig:pors}. Вычислительные издержки эквивалентны нескольким дополнительным вычислениям хэша для значительного повышения безопасности. В случае SPHINCS заметим, что противники имеют полный контроль над выбранным листом в гипердереве. Вместо этого мы предлагаем создать этот листовой индекс с помощью PRNG, что ещё больше повысит уровень безопасности. Этот увеличенный запас прочности позволяет уменьшить высоту гипердерева на 2 слоя, экономя 4616 байт.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.85]{PORS.png}
    \caption{Сравнение HORS и PORS}
    \label{fig:pors}
\end{figure}
\newpage

% Подписи без состояния
\section{Подписи без состояния}
\subsection{SPHINCS}
Представим основные идеи $SPHINCS$, описав его как комбинацию четырех типов деревьев. Ниже перечислены четыре типа деревьев (см. Рис. \ref{fig:SPHINCS}).

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.85]{SPHINCS.png}
    \caption{Пример $SPHINCS$. Гипердерево состоит из $d$ слоев дерева Меркля и соединены $WOTS$. Внизу дерево $HORS$(или $HORST$) соединяется с подписанным сообщением.}
    \label{fig:SPHINCS}
\end{figure}

1. Главное Гипердерево, высотой $h$ (60 в $SPHINCS-256$). Корень этого дерева является частью открытого ключа. Листья этого дерева экземпляры $HORST$. Это Гипердерево делится на $d$ слоев($d$ = 12 в $SPHINCS-256$).

2. Поддеревья, которые являются деревьями Меркля высоты $h/d$ (60/12 = 5 в $SPHINCS-256$). Листья этих деревьев являются корнями деревьев; указанные корни являются сжатыми открытыми ключами экземпляров $WOTS$, которые соединяются с деревом на следующем уровне.

3. Открытый ключ $WOTS$ это деревья сжатия, которые являются \newline L-деревьями, высоты $\lceil log_{2}l \rceil$, когда есть $l$ листья. Листья этого дерева являются компонентами $WOTS$ открытого ключа (67 значений по 256 бит каждое в $SPHINCS-256$). Связанный экземпляр $WOTS$ подписывает корень дерева на следующем уровне.

4. В нижней части гипердерева, открытый ключ $HORST$ - деревья сжатия это деревья Меркля высоты $\tau = log_{2}t$, где $t$ номер элементов открытого ключа $HORST$($2^{16}$ в $SPHINCS-256$).

Подписание в $SPHINCS$ работает следующим образом.

1. Извлекается листовой индекс из сообщения и личного ключа. Этот индекс определяет один из экземпляров $2^{h} HORST$ (относительно основного гипердерева), который будет использоваться для подписи сообщения.

2. Создайте экземпляр $HORST$, который является производным от личного ключа и конечного индекса, и подпишите сообщение этим экземпляром $HORST$. Подпись $HORST$ включает $k$ ключей и их соответствующие пути аутентификации и является частью подписи $SPHINCS$. Получите сжатый в дереве $HORST$ открытый ключ $p$.

3. Для каждого слоя гипердерева подпишите открытый ключ $p$(полученный из нижнего слоя), используя правильный экземпляр $WOTS$(полученный из листового индекса); добавьте эту подпись $WOTS$ и связанный с ней путь аутентификации к подписи $SPHINCS$. Вычислите путь аутентификации этого экземпляра $WOTS$ в поддереве. Добавьте этот путь к подписи $SPHINCS$ и $p$-корень поддерева.

Это краткое описание $SPHINCS$.
\subsection{Gravity-SPHINCS}
$Gravity-SPHINCS$ наследуют некоторые параметры от $SPHINCS$ (длина хэша, глубина $WOTS$ и др.), и имеет новые. В приведенном ниже списке $h$ обозначает высоту поддеревьев(в отличие от высоты основного дерева в $SPHINCS$), а $B_{n} = \{0,1\}^{n}$ обозначает набор $n$-битовых строк. Параметры являются следующими:

- Хэш-выход длина бита $n$, положительное целое число.

- Глубина $WOTS$ $w$, степень 2-ки такой, что $w \geq 2$ и $log_{2}w$ делит $n$.

- Размер множества $PORS$ $t$, положительное, степень двойки.

- Размер подмножества $PORS$ $k$, положительное целое такое, что $k \leq t$.

- Высота дерева Меркля $h$, положительное целое.

- Количество внутренних деревьев Меркля $d$, неотрицательное целое.

- Высота кэша $c$, неотрицательное целое.

- Высота $batching$ $b$, неотрицательное целое.

- Пространство сообщения $M$, обычно подмножество битовых строк $\{0,1\}^{*}$.

Из этих параметров получены:

- Размер $WOTS$ $l = \mu + \lfloor log_{2}(\mu(w - 1))/log_{2}w \rfloor + 1$, где $\mu = n/log_{2}w$.

- Множество $PORS$, $T = \{0, ..., t - 1\}$.

- Адресное пространство $A = \{0, ..., d\} \times \{0, ..., 2^{c + dh} - 1\} \times \{0, ..., max(l,t) - 1\}$.

- Пространство открытый ключей $PK = B_{n}$.

- Пространство личных ключей $SK = B^{2}_{n}$.

- Пространство подписи $SG = B_{n} \times B^{k}_{n} \times B^{\leq k(log_{2}t - \lfloor log_{2}k \rfloor)}_{n} \times (B^{l}_{n} \times B^{h}_{n})^{d} \times B^{c}_{n}$.

- $SG_{B} = B^{b}_{n} \times \{0, ..., 2^{b} - 1\} \times SG$

- Размер открытого ключа $n$ бит.

- Размер личного ключа, $2n$ бит.

- Максимальный размер подписи
\[sigsz = (1 + k +k(log_{2}t - \lfloor log_{2}k \rfloor) + d(l + h) + c)n\] бит.

Подписи $S$ одного сообщения и проверка $V$ в $Gravity-SPHINCS$ очень похожа на $SPHINCS$.

Алгоритм генерации ключей. $KG$ получает на вход $2n$ случайных бит и на выходе получаем личный ключ $sk \in B^{2}_{n}$, и открытый ключ $pk \in B_{n}$.

- Генерация личного ключа из $2n$ случайных бит $sk = (seed, salt) \stackrel{\$}{\leftarrow} B^{2}_{n}$.

- Для $0 \leq i < 2^{c+h}$ генерируется $Winternitz$ открытый ключ
\[x_{i} \leftarrow WOTS-genpk(seed, make-addr(0, i))\]

- Генерация открытого ключа $pk \leftarrow Merkle-root_{c+h}(x_{0}, ..., x_{2^{c+h} - 1})$.

Алгоритм подписи. $S$ на вход принимает хэш $m \in B_{n}$ и личный ключ $sk = (seed, salt)$, и на выходе получаем подпись.

- Вычисляем $s \leftarrow H(salt, m)$.

- Вычисляем гипердерева индекс и случайное подмножество как
\[j, (x_{1}, ..., x_{k}) \leftarrow PORS(s, m)\]

- Вычисляем $PORST$ подпись и открытый ключ
\[(\sigma_{d}, oct, p) \leftarrow PORST-sign(seed, make-addr(d, j), x_{1}, ..., x_{k})\]

- Для $i \in \{d - 1, ..., 0\}$ выполняется:

1. Вычисляем $WOTS$ подпись $\sigma_{i} \leftarrow WOTS-sign(seed, make-addr(i,j),p)$,

2. Вычисляем $p \leftarrow WOTS-extractpk(p, \sigma_{i})$,

3. $j^{*} \leftarrow \lfloor j / 2^{h} \rfloor$,

4. Для $u \in \{0, ..., 2^{h} - 1\}$ вычислим $WOTS$ открытый ключ
\[p_{u} \leftarrow WOTS-genpk(seed, make-addr(i, 2^{h}, j^{*} + u))\]

5. Вычислим Меркля аутентификацию $A_{i} \leftarrow Merkle-auth_{h}(p_{0}, ..., p_{2^{h} - 1}, j - 2^{h}j^{*})$,

6. $j \leftarrow j^{*}$.

- Для $0 \leq u < 2^{c+h}$ вычислим WOTS открытый ключ
\[p_{u} \leftarrow WOTS-genpk(seed, make-addr(0, u))\]

- Вычислим Меркля аутентификацию
\[(a_{1}, ..., a_{h+c}) \leftarrow Merkle-auth_{h+c}(p_{0}, ..., p_{2^{h+c} - 1}, 2^{h}j)\]

- $A_{c} \leftarrow (a_{h+1}, ..., a_{h+c})$.

- Получаем подпись $(s, \sigma_{d}, oct, \sigma_{d - 1}, A_{d - 1}, ..., \sigma_{0}, A_{0}, A_{c})$.

Алгоритм проверки. $V$ получает на вход хэш $m \in B_{n}$, открытый ключ $pk \in B_{n}$ и подпись
\[(s, \sigma_{d}, oct, \sigma_{d - 1}, A_{d - 1}, ..., \sigma_{0}, A_{0}, A_{c})\]
и проверяет это следующим образом.

- Вычислим индекс гипердерева и случайное подмножество
\[j, (x_{1}, ..., x_{k}) \leftarrow PORS(s,m)\]

- Вычислим открытый ключ $PORST$,
\[p \leftarrow PORST-extractpk(x_{1}, ..., x_{k}, \sigma_{d}, oct).\]

- Если $p = \perp$, затем прерываем и возвращаем 0.

- Для $i \in \{d - 1, ..., 0\}$ выполняем следующее:

1. Вычислим открытый ключ $WOTS$, $p \leftarrow WOTS-extractpk(p, \sigma_{i})$,

2. $j^{*} \leftarrow \lfloor j/2^{h} \rfloor$,

3. Вычислим корень дерева Меркля, $p \leftarrow Merkle-extract_{h}(p, j - 2^{h}j^{*}, A_{i})$,

4. $j \leftarrow j^{*}$.

- Вычислим корень дерева Меркля, $p \leftarrow Merkle-extract_{c}(p, j, A_{c})$.

- В результате 1, если $p = pk$ и 0 иначе.
\subsection{SPHINCS+}
$SPHINCS^{+}$ использует псевдослучайную функцию $PRF$ для псевдослучайности генерации ключей, $PRF : \{0, 1\}^{n} \times \{0, 1\}^{256} \rightarrow \{0, 1\}^{n}$, и псевдослучайную функцию $PRF_{msg}$ для генерации случайного сжатия сообщения: $PRF_{msg} : \{0, 1\}^{n} \times \{0, 1\}^{n} \times \{0, 1\}^{*} \rightarrow \{0, 1\}^{n}$. Для сжатия подписываемого сообщения мы используем дополнительную хэш-функцию $H_{msg}$, которая может обрабатывать сообщения произвольной длины:
\[H_{msg} : \{0, 1\}^{n} \times \{0, 1\}^{n} \times \{0, 1\}^{n} \times \{0, 1\}^{*} \rightarrow \{0, 1\}^{m}\]
$SPHINCS^{+}$ Личный и открытый ключи. Открытый ключ состоит из двух $n$-битных значений: корневого узла из трех верхних в гипердереве и случайного открытого начального значения $PK$. Кроме того, личный ключ состоит еще из двух n-битных случайных: $SK$, чтобы генерировать $WOTS^{+}$ и $FORS$ личные ключи, и $SK.prf$, используемый ниже для рандомизированного дайджеста сообщений.

$SPHINCS^{+}$ Подпись. Как не удивительно, что подпись состоит из $FORS$ подписи для дайджеста сообщения, $WOTS^{+}$ подпись соответствующих открытых ключей $FORS$, и ряд каналов аутентификации и $WOTS^{+}$ подписи для подтверждения того, что $WOTS^{+}$ открытый ключ. Чтобы проверить эту цепочку путей и подписей, проверка итеративно восстанавливает открытые ключи и корневые узлы до тех пор, пока не будет достигнут корневой узел в верхней части гипердерева $SPHINCS^{+}$. Два момента еще не были рассмотрены: вычисление дайджеста сообщения и выбор листа. Здесь $SPHINCS^{+}$ отличается от оригинальных $SPHINCS$ тонкими, но важными деталями.

Во-первых, мы псевдо случайным образом генерируем рандомизатор $R$, основанный на сообщении и $SK.prf$. $R$ может быть дополнительно сделан недетерминированным путем добавления дополнительной случайности $OptRand$. Это может противодействовать атакам бокового канала, которые полагаются на сбор нескольких следов для одного и того же вычисления. Обратите внимание, что установка этого значения в нулевую строку (или использование значения с низкой энтропией) не оказывает отрицательного влияния на псевдослучайность $R$. Формально, мы полагем, что $R = PRF(SK.prf, OptRand, M)$. $R$ часть подписи. Используя $R$, мы затем получаем индекс конечного узла, который должен использоваться, а также дайджест сообщения $(MD||idx) = H_{msg}(R, PK, PK.root, M)$.

В отличие от $SPHINCS$, этот метод выбора индекса является публично проверяемым, не позволяя злоумышленнику свободно выбирать кажущийся случайным индекс и комбинировать его с сообщением по своему выбору. Критически важно, что это противодействует многоцелевым атакам на схему подписи нескольких раз. Поскольку индекс теперь может быть вычислен верификатором, он больше не включается в подпись.
\newpage

% Сравнение Stateful && Stateless
\section{Stateful vs Stateless}
Схемы с сохранением состояния имеют дерево Меркля с количеством одноразовых подписей внизу. Каждая разовая подпись может быть использована один раз, следовательно, подписывающий должен отслеживать, какие из них он использовал. То есть, когда он использует одноразовую подпись для подписи сообщения, он должен обновить свое состояние.

Схемы без состояния имеют большое дерево, но внизу у них есть несколько подписей времени. Каждая такая небольшая временная подпись может подписать несколько сообщений. Таким образом, когда подписывается сообщение, подписывающий выбирает случайную подпись с небольшим количеством времени, использует ее для подписи сообщения, а затем подтверждает ее подлинность через деревья Меркля вплоть до корня, который является открытым ключом. Поскольку мы используем несколько раз подпись, мы не против, если мы иногда выбираем одну и ту же подпись несколько раз. Схема подписи нескольких раз может справиться с этим. И, поскольку нам не нужно обновлять какое-либо состояние при генерации подписи, это считается «без сохранения состояния».
\newpage

% Результаты
\section{Результаты}
Создание на Macbook Pro(3.1 GHz i5, 8GB оперативной памяти), пар ключей одноразовой подписи и дерева сертификации Меркля разных размеров дало следующие результаты($WOTS$): $2^4 = 0.465s, 2^5 = 1.135s, 2^6 = 3.650s, 2^8 = 14.540s$. Создание гипердерева, состоящего из начальной генерации двух $2^4$ деревьев, занимает около 1 секунды по сравнению с $~14s$, требующимися для генерации стандартного $2^8$ дерева $MSS$ для одного и того же объема подписей. 

Общая идея гипердерева состоит в том, что корень дочернего дерева Меркля подписывается ключом одноразовой подписи из хэша листа родительского дерева Меркля, известного как дерево сертификации. Проблема с базовой $MSS$ заключается в том, что количество доступных подписей ограничено, и все пары ключей одноразовых подписей должны быть предварительно сгенерированы до вычисления дерева Меркля. Генерация ключей и время подписания растут экспоненциально относительно высоты дерева, $h$, что означает, что деревья, превышающие 256 ключей одноразовой подписи, становятся затратными по параметрам времени и вычислительной мощности, необходимых для генерации. Стратегия отсрочки вычислений при генерации ключей и деревьев, а также расширение количества доступных пар ключей одноразовой подписи заключается в использовании дерева, которое само состоит из деревьев Меркля, называемого гипердеревом. Размер подписей растет линейно для каждого дополнительного дерева, которое подписывается, в то время как объём подписей гипердерева увеличиваентся экспоненциально.

Увеличение глубины(или высоты) гипердерева продолжает эту тенденцию. Гипердерево, состоящее из четырех соединенных $2^4$ деревьев сертификации и дерева подписи размером $2^4$, может содержать $2^{20} = 1 048 576$ подписей с увеличенным размером подписи, но при этом время создания составляет всего $2.420s$.

Нет необходимости, чтобы гипердерево было симметричным, и поэтому, если оно состояло первоначально из двух деревьев, оно может быть расширено впоследствии путем присоединения дополнительных слоев деревьев. Таким образом, подлписи блока транзакций будут изначально небольшого размера, который будет постепенно возрастать по мере увеличения глубины гипердерева. Использование гипердерева Меркля для создания и подписи адреса блока транзакций вряд ли потребуется для количества транзакций превышающего $2^{12}$. Таким образом, возможность создать с вычислительной легкостью $2^{20}$ защищенных подписей для глубины гипердерева $h = 5$ является более чем достаточной.
\newpage

Использование схемы подписи Меркля $MSS$ безопасно основывается на неиспользовании повторно ключей одноразовой подписи. Таким образом, это зависит только от состояния подписей или записей о подписанных транзакциях. Как правило, в реальном мире это потенциально может быть проблемой, но неизменяемый публичный блок цепочки транзакций является идеальным хранилищем для криптографической схемы подписи с учетом состояния. В 2015 году стало известно о новой схеме криптографической подписи на основе хэшей под названием $SPHINCS$ (с алгоритмом подписи можно ознакомится выше), которая предлагает практически не зависящие от состояния подписи с $2^{128}$-битной защитой.
\begin{table}[h!]
    \begin{center}
      \caption{Сравнение подписей}
      \label{tab:table1}
      \begin{tabular}{l|c|c|c}
        \textbf{Algorithm} & \textbf{Key generation} & \textbf{Sign} & \textbf{Verify}\\
        \hline
        SPHINCS-256 & 12.6 ms & 236 ms & 2.73 ms\\
        ECDSA(P-256) & 0.924 ms & 0.553 ms & 0.478 ms\\
      \end{tabular}
    \end{center}
  \end{table}
\newpage

% Заключение
\section{Заключение}
Применение подписей происходит повсеместно, например в блокчейнах таких как ($Bitcoin$, $Bitshares$). Поэтому безопасность этих технологий находится также под угрозой. Есть возможность и ещё время, защитить потенциальную угрозу, написав блокчейн устойчивый к квантовым атакам. Заменив подпись на элиптических кривых, подписью на основе функций хэширования.

На преддипломной практике получилось реализовать подпись без сохранения состояния $SPHINCS$(см. Приложение) и интегрировать её реализацию в криптовалюту $Bitshares$. 
\newpage

% Cписок литературы
\section{Cписок литературы}
[1] Security of One-Time Signatures under Two-Message Attacks. Andreas Hülsing. https://eprint.iacr.org/2016/1042.pdf.
\newline
\newline
[2] On the Security of the Winternitz One-Time Signature Scheme. Johannes Buchmann, Erik Dahmen, Sarah Ereth. https://eprint.iacr.org/2011/191.pdf.
\newline
\newline
[3] Short One-Time Signatures. Gregory M. Zaverucha and Douglas R. Stinson. https://eprint.iacr.org/2010/446.pdf.
\newline
\newline
[4] $W-OTS^{+}$ – Shorter Signatures for Hash-Based Signature Schemes. Andreas Hulsing. https://eprint.iacr.org/2017/965.pdf.
\newline
\newline
[5] Proof-of-forgery for hash-based signatures. E.O. Kiktenko, M.A. Kudinov, A.A. Bulychev, and A.K. Fedorov. https://arxiv.org/pdf/1905.12993.pdf.
\newline
\newline
[6] Improving Stateless Hash-Based Signatures. Jean-Philippe Aumasson and Guillaume Endignoux. https://eprint.iacr.org/2017/933.pdf.
\newline
\newline
[7] The $SPHINCS^{+}$ Signature Framework. Daniel J. Bernstein. https://eprint.iacr.org/2019/1086.pdf.
\newline
\newline
[8] Design and implementation of a post-quantum
hash-based cryptographic signature scheme. Guillaume Endignoux. https://gendignoux.com/assets/pdf/2017-07-master-thesis-endignoux-report.pdf.
\newpage

% Приложение
\section{Приложение}
\begin{verbatim}
class SPHINCS(object):

    #    def __init__(self, n=256, m=512, h=60, d=12, w=16, tau=16, k=32):
    def __init__(self, n=256, m=512, h=60, d=12, w=16, tau=16, k=32):

        self.n = n
        self.m = m
        self.h = h
        self.d = d
        self.w = w
        self.tau = tau
        self.t = 1 << tau
        self.k = k

        self.Hdigest = lambda r, m: BLAKE(512).digest(r + m)
        self.Fa = lambda a, k: BLAKE(256).digest(k + a)
        self.Frand = lambda m, k: BLAKE(512).digest(k + m)

        C = bytes("expand 32-byte to 64-byte state!", 'latin-1')
        perm = ChaCha().permuted
        self.Glambda = lambda seed, n: ChaCha(key=seed).keystream(n)
        self.F = lambda m: perm(m + C)[:32]
        self.H = lambda m1, m2: perm(xor(perm(m1 + C), m2 + bytes(32)))[:32]

        self.wots = WOTSplus(n=n, w=w, F=self.F, Gl=self.Glambda)
        self.horst = HORST(n=n, m=m, k=k, tau=tau,
                           F=self.F, H=self.H, Gt=self.Glambda)

    def address(self, level, subtree, leaf):
        t = level | (subtree << 4) | (leaf << 59)
        return int.to_bytes(t, length=8, byteorder='little')

    def wots_leaf(self, address, SK1, masks):
        seed = self.Fa(address, SK1)
        pk_A = self.wots.keygen(seed, masks)

        def H(x, y, i): return self.H(xor(x, masks[2*i]), xor(y, masks[2*i+1]))
        return root(l_tree(H, pk_A))

    def wots_path(self, a, SK1, Q, subh):
        ta = dict(a)
        leafs = []
        for subleaf in range(1 << subh):
            ta['leaf'] = subleaf
            leafs.append(self.wots_leaf(self.address(**ta), SK1, Q))
        Qtree = Q[2 * ceil(log(self.wots.l, 2)):]

        def H(x, y, i): return self.H(xor(x, Qtree[2*i]), xor(y, Qtree[2*i+1]))
        tree = list(hash_tree(H, leafs))
        return auth_path(tree, a['leaf']), root(tree)

    def keygen(self):
        SK1 = os.urandom(self.n // 8)
        SK2 = os.urandom(self.n // 8)
        p = max(self.w-1, 2 * (self.h + ceil(log(self.wots.l, 2))), 2*self.tau)
        Q = [os.urandom(self.n // 8) for _ in range(p)]
        PK1 = self.keygen_pub(SK1, Q)
        return (SK1, SK2, Q), (PK1, Q)

    def keygen_pub(self, SK1, Q):
        addresses = [self.address(self.d - 1, 0, i)
                     for i in range(1 << (self.h//self.d))]
        leafs = [self.wots_leaf(A, SK1, Q) for A in addresses]
        Qtree = Q[2 * ceil(log(self.wots.l, 2)):]

        def H(x, y, i): return self.H(xor(x, Qtree[2*i]), xor(y, Qtree[2*i+1]))
        PK1 = root(hash_tree(H, leafs))
        return PK1

    def sign(self, M, SK):
        SK1, SK2, Q = SK

        R = self.Frand(M, SK2)
        R1, R2 = R[:self.n // 8], R[self.n // 8:]
        D = self.Hdigest(R1, M)
        i = int.from_bytes(R2, byteorder='big')
        i >>= self.n - self.h
        subh = self.h // self.d
        a = {'level': self.d,
             'subtree': i >> subh,
             'leaf': i & ((1 << subh) - 1)}
        a_horst = self.address(**a)
        seed_horst = self.Fa(a_horst, SK1)
        sig_horst, pk_horst = self.horst.sign(D, seed_horst, Q)
        pk = pk_horst
        sig = [i, R1, sig_horst]
        for level in range(self.d):
            a['level'] = level
            a_wots = self.address(**a)
            seed_wots = self.Fa(a_wots, SK1)
            wots_sig = self.wots.sign(pk, seed_wots, Q)
            sig.append(wots_sig)
            path, pk = self.wots_path(a, SK1, Q, subh)
            sig.append(path)
            a['leaf'] = a['subtree'] & ((1 << subh) - 1)
            a['subtree'] >>= subh
        return tuple(sig)

    def verify(self, M, sig, PK):
        i, R1, sig_horst, *sig = sig
        PK1, Q = PK
        Qtree = Q[2 * ceil(log(self.wots.l, 2)):]
        D = self.Hdigest(R1, M)
        pk = pk_horst = self.horst.verify(D, sig_horst, Q)
        if pk_horst is False:
            return False
        subh = self.h // self.d

        def H(x, y, i): return self.H(xor(x, Q[2*i]), xor(y, Q[2*i+1]))

        def Ht(x, y, i): return self.H(
            xor(x, Qtree[2*i]), xor(y, Qtree[2*i+1]))
        for _ in range(self.d):
            wots_sig, wots_path, *sig = sig
            pk_wots = self.wots.verify(pk, wots_sig, Q)
            leaf = root(l_tree(H, pk_wots))
            pk = construct_root(Ht, wots_path, leaf, i & 0x1f)
            i >>= subh
        return PK1 == pk
\end{verbatim}
\newpage

\end{document}
% Конец документа